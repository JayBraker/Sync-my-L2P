name: Build

on: [push]

env:
  QT_VERSION: "6.1.0"
  QT_CREATOR_VERSION: "4.15.0"
  CMAKE_VERSION: 3.19.8
  NINJA_VERSION: 1.10.1
  INSTALL_BUILDER_VERSION: "20.4.0"
  PRODUCT_PRO: "Sync-my-L2P.pro"
  PRODUCT_NAME: "SyncMyL2P"
  CLIENT_ID: ${{ secrets.CLIENT_ID }}
  INSTALLBUILDER_LICENSE: ${{ secrets.INSTALLBUILDER_LICENSE }}

jobs:
  build:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      matrix:
        config:
        - {
            name: "Windows Server 2019",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-windows.exe",
            os: windows-2019,
            environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat",
            c_compiler: cl,
            cxx_compiler: cl
          }
        - {
            name: "Ubuntu 20.04",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-linux.AppImage",
            os: ubuntu-20.04,
            c_compiler: gcc,
            cxx_compiler: g++
          }
        - {
            name: "macOS Catalina 10.15",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-osx.dmg",
            os: macos-10.15,
            c_compiler: clang,
            cxx_compiler: clang++
          }

    steps:
    - uses: actions/checkout@v2

    - name: Parse product version
      id: version
      shell: cmake -P {0}
      run: |
        file(READ ./include/version.h version_h_content)
        string(REGEX MATCH "#define PRODUCT_VERSION_CODE ([0-9]+)" unused "${version_h_content}")
        set(version_code ${CMAKE_MATCH_1})
        string(REGEX MATCH "#define PRODUCT_VERSION \"([^\"]+)\"" unused "${version_h_content}")
        set(version_humanreadable ${CMAKE_MATCH_1})

        # store for upload
        file(WRITE ./version.txt "${version_code}")
        file(WRITE ./version_humanreadable.txt "${version_humanreadable}")

        # store for use in other steps
        message("::set-output name=code::${version_code}")
        message("::set-output name=humanreadable::${version_humanreadable}")

    - name: Upload version code
      uses: actions/upload-artifact@v1
      with:
        name: version.txt
        path: ./version.txt

    - name: Upload human-readable version
      uses: actions/upload-artifact@v1
      with:
        name: version_humanreadable.txt
        path: ./version_humanreadable.txt

    - name: Inserting OAuth 2.0 Client ID in Header file
      shell: cmake -P {0}
      run: |
        file(READ ./include/clientId.h clientid_h_content)
        string(REGEX REPLACE "#define CLIENTID[^\r\n]*" "#define CLIENTID \"$ENV{CLIENT_ID}\"" clientid_h_content "${clientid_h_content}")
        string(REGEX REPLACE "#error[^\r\n]*" "" clientid_h_content "${clientid_h_content}")
        file(WRITE ./include/clientId.h "${clientid_h_content}")

    - name: Download Ninja and CMake
      shell: cmake -P {0}
      run: |
        set(cmake_version "$ENV{CMAKE_VERSION}")
        set(ninja_version "$ENV{NINJA_VERSION}")

        if ("${{ runner.os }}" STREQUAL "Windows")
          set(ninja_suffix "win.zip")
          set(cmake_suffix "win64-x64.zip")
          set(cmake_dir "cmake-${cmake_version}-win64-x64/bin")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(ninja_suffix "linux.zip")
          set(cmake_suffix "Linux-x86_64.tar.gz")
          set(cmake_dir "cmake-${cmake_version}-Linux-x86_64/bin")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(ninja_suffix "mac.zip")
          set(cmake_suffix "Darwin-x86_64.tar.gz")
          set(cmake_dir "cmake-${cmake_version}-Darwin-x86_64/CMake.app/Contents/bin")
        endif()

        set(ninja_url "https://github.com/ninja-build/ninja/releases/download/v${ninja_version}/ninja-${ninja_suffix}")
        file(DOWNLOAD "${ninja_url}" ./ninja.zip SHOW_PROGRESS)
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./ninja.zip)

        set(cmake_url "https://github.com/Kitware/CMake/releases/download/v${cmake_version}/cmake-${cmake_version}-${cmake_suffix}")
        file(DOWNLOAD "${cmake_url}" ./cmake.zip SHOW_PROGRESS)
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./cmake.zip)

        # Add to PATH environment variable
        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/${cmake_dir}" cmake_dir)
        set(path_separator ":")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(path_separator ";")
        endif()
        file(APPEND "$ENV{GITHUB_PATH}" "$ENV{GITHUB_WORKSPACE}${path_separator}${cmake_dir}")

        if (NOT "${{ runner.os }}" STREQUAL "Windows")
          execute_process(
            COMMAND chmod +x ninja
            COMMAND chmod +x ${cmake_dir}/cmake
          )
        endif()

    - name: Installing system libs
      id: syslibs
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Linux")
          execute_process(
            COMMAND sudo apt install libgl1-mesa-dev libxkbcommon-x11-0
          )
        endif()

    - name: Download Qt
      id: qt
      shell: cmake -P {0}
      run: |
        set(qt_version $ENV{QT_VERSION})

        string(REPLACE "." "" qt_version_dotless "${qt_version}")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(url_os "windows_x86")
          set(qt_package_name "qt.qt6.${qt_version_dotless}.win64_msvc2019_64")
          set(qt_dir_prefix "${qt_version}/msvc2019_64")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(url_os "linux_x64")
          set(qt_package_name "qt.qt6.${qt_version_dotless}.gcc_64")
          set(qt_dir_prefix "${qt_version}/gcc_64")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(url_os "mac_x64")
          set(qt_package_name "qt.qt6.${qt_version_dotless}.clang_64")
          set(qt_dir_prefix "${qt_version}/clang_64")
        endif()

        set(qt_base_url "https://download.qt.io/online/qtsdkrepository/${url_os}/desktop/qt6_${qt_version_dotless}")
        file(DOWNLOAD "${qt_base_url}/Updates.xml" ./Updates.xml SHOW_PROGRESS)

        file(READ ./Updates.xml updates_xml)
        string(REGEX MATCH "<Name>${qt_package_name}.*<Version>([0-9+-.]+)</Version>.*<DownloadableArchives>qtbase([a-zA-Z0-9_-]+).7z"
          updates_xml_output "${updates_xml}")
        set(package_version ${CMAKE_MATCH_1})
        set(package_suffix ${CMAKE_MATCH_2})
        string(REPLACE "-debug-symbols" "" package_suffix "${package_suffix}")

        file(MAKE_DIRECTORY qt6)

        # Save the path for other steps
        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/qt6/${qt_dir_prefix}" qt_dir)
        message("::set-output name=qt_dir::${qt_dir}")

        message("Downloading Qt to ${qt_dir}")
        function(downloadAndExtract url archive)
          message("Downloading ${url}")
          file(DOWNLOAD "${url}" ./${archive} SHOW_PROGRESS)
          execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ../${archive} WORKING_DIRECTORY qt6)
        endfunction()

        foreach(package qtbase qtdeclarative qttools qtsvg qttranslations)
          downloadAndExtract(
            "${qt_base_url}/${qt_package_name}/${package_version}${package}${package_suffix}.7z"
            ${package}.7z
          )
        endforeach()

        # uic depends on libicu56.so
        if ("${{ runner.os }}" STREQUAL "Linux")
          downloadAndExtract(
            "${qt_base_url}/${qt_package_name}/${package_version}icu-linux-Rhel7.2-x64.7z"
            icu.7z
          )
        endif()

        file(READ "qt6/${qt_dir_prefix}/mkspecs/qconfig.pri" qtconfig)
        string(REPLACE "Enterprise" "OpenSource" qtconfig "${qtconfig}")
        string(REPLACE "licheck.exe" "" qtconfig "${qtconfig}")
        string(REPLACE "licheck64" "" qtconfig "${qtconfig}")
        string(REPLACE "licheck_mac" "" qtconfig "${qtconfig}")
        file(WRITE "qt6/${qt_dir_prefix}/mkspecs/qconfig.pri" "${qtconfig}")

    - name: Download Qt Tool OpenSSL
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(qt_package_name "qt.tools.openssl.win_x64")
          set(qt_package_folder "tools_openssl_x64")

          set(qt_base_url "https://download.qt.io/online/qtsdkrepository/windows_x86/desktop/${qt_package_folder}")
          file(DOWNLOAD "${qt_base_url}/Updates.xml" ./Updates.xml SHOW_PROGRESS)

          file(READ ./Updates.xml updates_xml)
          string(REGEX MATCH "<Name>${qt_package_name}.*<Version>([0-9+-.]+)</Version>.*<DownloadableArchives>(openssl[a-zA-Z0-9._-]+).7z"
            updates_xml_output "${updates_xml}")
          set(package_version ${CMAKE_MATCH_1})
          set(package_name ${CMAKE_MATCH_2})
          string(REPLACE "-debug-symbols" "" package_name "${package_name}")

          file(DOWNLOAD
            "${qt_base_url}/${qt_package_name}/${package_version}${package_name}.7z" ./openssl.7z
            SHOW_PROGRESS
          )
          execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ../openssl.7z WORKING_DIRECTORY qt6)
        endif()

    - name: Download Qt Creator
      id: qt_creator
      shell: cmake -P {0}
      run: |
        string(REGEX MATCH "([0-9]+.[0-9]+).[0-9]+" outvar "$ENV{QT_CREATOR_VERSION}")

        set(qtc_base_url "https://download.qt.io/official_releases/qtcreator/${CMAKE_MATCH_1}/$ENV{QT_CREATOR_VERSION}/installer_source")

        if ("${{ runner.os }}" STREQUAL "Windows")
          set(qtc_output_directory "bin")
          set(qtc_platform "windows_x64")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(qtc_output_directory "bin")
          set(qtc_platform "linux_x64")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(qtc_output_directory "bin/Sync-my-L2P.app/Contents/MacOS")
          set(qtc_platform "mac_x64")
        endif()

        # Save the path for other steps
        message("::set-output name=qtc_output_directory::${qtc_output_directory}")

        file(MAKE_DIRECTORY qtcreator)

        message("Downloading Qt Creator from ${qtc_base_url}/${qtc_platform}")

        file(DOWNLOAD
          "${qtc_base_url}/${qtc_platform}/qtcreator.7z" ./qtcreator.7z SHOW_PROGRESS)
        execute_process(COMMAND
          ${CMAKE_COMMAND} -E tar xvf ../qtcreator.7z WORKING_DIRECTORY qtcreator)

        if ("${{ runner.os }}" STREQUAL "macOS")
          execute_process(
            COMMAND ${CMAKE_COMMAND} -E make_directory qtcreator/bin
            COMMAND ${CMAKE_COMMAND} -E create_symlink
              "$ENV{GITHUB_WORKSPACE}/qtcreator/Qt Creator.app"
              "$ENV{GITHUB_WORKSPACE}/qtcreator/bin/Qt Creator.app"
          )
        endif()

        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/qtcreator" qtc_directory)

        # Save the path for other steps
        message("::set-output name=qtc_directory::${qtc_directory}")

    - name: Download VMware InstallBuilder
      id: installbuilder
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Windows")
          # Create license file from template
          file(READ ./windows/license.xml.template license_xml_content)
          string(REGEX REPLACE "<signature>[^\r\n]*</signature>" "<signature>$ENV{INSTALLBUILDER_LICENSE}</signature>" license_xml_content "${license_xml_content}")
          file(WRITE ./installbuilder/license.xml "${license_xml_content}")

          set(ib_installer "installbuilder-enterprise-$ENV{INSTALL_BUILDER_VERSION}-windows-installer.exe")
          set(ib_installer_url "https://installbuilder.com/${ib_installer}")

          file(MAKE_DIRECTORY installbuilder)

          file(DOWNLOAD
            "${ib_installer_url}" ./${ib_installer} SHOW_PROGRESS)
          execute_process(COMMAND
            ./${ib_installer} --mode unattended --prefix ./installbuilder)
        endif()

    - name: Configure
      shell: cmake -P {0}
      run: |
        if (NOT "${{ runner.os }}" STREQUAL "Windows")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/Qt/lib:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator/plugins:$ENV{LD_LIBRARY_PATH}")
        endif()

        if ("${{ runner.os }}" STREQUAL "Windows" AND NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
          execute_process(
            COMMAND "${{ matrix.config.environment_script }}" && set
            OUTPUT_FILE environment_script_output.txt
          )
          file(STRINGS environment_script_output.txt output_lines)
          foreach(line IN LISTS output_lines)
            if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
              set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
            endif()
          endforeach()
        endif()

        execute_process(
          COMMAND cmake
            -DCMAKE_PREFIX_PATH=./qt6;./qtcreator
            -DCMAKE_BUILD_TYPE=Release
            -G Ninja
            -DCMAKE_C_COMPILER=${{ matrix.config.c_compiler }}
            -DCMAKE_CXX_COMPILER=${{ matrix.config.cxx_compiler }}
            -DCMAKE_MAKE_PROGRAM=ninja
            -DQT_DIR=${{ steps.qt.outputs.qt_dir }}
            .
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

    - name: Build
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Windows")
          if (NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
            execute_process(
              COMMAND "${{ matrix.config.environment_script }}" && set
              OUTPUT_FILE environment_script_output.txt
            )
            file(STRINGS environment_script_output.txt output_lines)
            foreach(line IN LISTS output_lines)
              if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
                set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
              endif()
            endforeach()
          endif()
          set(ENV{PATH} "${{ steps.qt.outputs.qt_dir }}/bin/;$ENV{PATH}")
        else()
          set(ENV{PATH} "${{ steps.qt.outputs.qt_dir }}/bin/:$ENV{PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/Qt/lib:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator/plugins:$ENV{LD_LIBRARY_PATH}")
        endif()

        execute_process(
          COMMAND cmake --build .
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

    - name: Create installer
      id: installer
      shell: cmake -P {0}
      run: |
        string(REPLACE "PRODUCT_VERSION" "${{ steps.version.outputs.humanreadable }}" artifact_name "${{ matrix.config.artifact }}")
        set(artifact_path "./${artifact_name}")

        # Save installer name and path for the next step
        message("::set-output name=artifact_name::${artifact_name}")
        message("::set-output name=artifact_path::${artifact_path}")

        if ("${{ runner.os }}" STREQUAL "Windows")
          execute_process(
            COMMAND ${{ steps.qt.outputs.qt_dir }}/bin/windeployqt
              "${{ steps.qt_creator.outputs.qtc_output_directory }}"
              --compiler-runtime
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          set(installer_platform "windows-x64")

          execute_process(
            COMMAND ./installbuilder/bin/builder-cli.exe
              build ./windows/SyncMyL2P.xml ${installer_platform}
              --license ./installbuilder/license.xml --verbose
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          file(RENAME "./windows/build/$ENV{PRODUCT_NAME}-${{ steps.version.outputs.humanreadable }}-${installer_platform}-installer.exe" "${artifact_path}")

        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(ENV{PATH} "${{ steps.qt.outputs.qt_dir }}/bin/:$ENV{PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/Qt/lib:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator/plugins:$ENV{LD_LIBRARY_PATH}")

          file(DOWNLOAD "https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage"
            ./linux/linuxdeployqt-continuous-x86_64.AppImage SHOW_PROGRESS)
          execute_process(COMMAND dos2unix Sync-my-L2P.desktop WORKING_DIRECTORY ./linux/)
          execute_process(COMMAND sudo chmod a+x ./linuxdeployqt-continuous-x86_64.AppImage WORKING_DIRECTORY ./linux/)
          execute_process(COMMAND ./linuxdeployqt-continuous-x86_64.AppImage --appimage-extract WORKING_DIRECTORY ./linux/)
          set(ENV{PATH} "$ENV{GITHUB_WORKSPACE}/linux/squashfs-root/usr/bin/:$ENV{PATH}")
          file(MAKE_DIRECTORY "linux/usr/bin")
          file(COPY "./bin/Sync-my-L2P" DESTINATION "./linux/usr/bin/")
          set(ENV{VERSION} "${{ steps.version.outputs.humanreadable }}")
          execute_process(COMMAND ./squashfs-root/AppRun ./usr/bin/Sync-my-L2P -verbose=1 -appimage WORKING_DIRECTORY ./linux/)

          file(RENAME "./linux/Sync-my-L2P-$ENV{VERSION}-x86_64.AppImage" "${artifact_path}")

        elseif ("${{ runner.os }}" STREQUAL "macOS")
          execute_process(
            COMMAND npm install -g create-dmg fileicon
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND ${{ steps.qt.outputs.qt_dir }}/bin/macdeployqt Sync-my-L2P.app
            WORKING_DIRECTORY ./bin
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND fileicon set Sync-my-L2P.app ../magnifier.ico
            WORKING_DIRECTORY ./bin
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND create-dmg Sync-my-L2P.app
            WORKING_DIRECTORY ./bin
            RESULT_VARIABLE result
          )
          # if (NOT result EQUAL 0)
          #   message(FATAL_ERROR "Bad exit status")
          # endif()

          # TODO sign dmg

          file(RENAME "./bin/Sync-my-L2P ${{ steps.version.outputs.humanreadable }}.dmg" "${artifact_path}")
        endif()

    - uses: actions/upload-artifact@v1
      id: upload_artifact
      with:
        name: ${{ steps.installer.outputs.artifact_name }}
        path: ${{ steps.installer.outputs.artifact_path }}

  release:
    if: contains(github.ref, 'tags/v')
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1.0.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

    - name: Store Release url
      run: |
        echo "${{ steps.create_release.outputs.upload_url }}" > ./upload_url

    - uses: actions/upload-artifact@v1
      with:
        path: ./upload_url
        name: upload_url

  publish:
    if: contains(github.ref, 'tags/v')

    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      matrix:
        config:
        - {
            name: "Windows Server 2019",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-windows-x64.exe",
            os: windows-2019,
          }
        - {
            name: "Ubuntu 20.04",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-linux.AppImage",
            os: ubuntu-20.04
          }
        - {
            name: "macOS Catalina 10.15",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-osx.dmg",
            os: macos-10.15
          }
    needs: release

    steps:
    - name: Download human-readable version
      uses: actions/download-artifact@v1
      with:
        name: version_humanreadable.txt
        path: ./

    - name: Generate filename for upload
      id: filename
      shell: cmake -P {0}
      run: |
        file(READ ./version_humanreadable.txt version_humanreadable)
        string(REPLACE "PRODUCT_VERSION" "${version_humanreadable}" artifact_name "${{ matrix.config.artifact }}")

        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/${artifact_name}" artifact_path)
        
        # store for use in other steps
        message("::set-output name=artifact_name::${artifact_name}")
        message("::set-output name=artifact_path::${artifact_path}")

    - name: Download artifact
      uses: actions/download-artifact@v1
      with:
        name: ${{ steps.filename.outputs.artifact_name }}
        path: ./

    - name: Download URL
      uses: actions/download-artifact@v1
      with:
        name: upload_url
        path: ./
    - id: set_upload_url
      run: |
        upload_url=`cat ./upload_url`
        echo ::set-output name=upload_url::$upload_url

    - name: Upload to Release
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.set_upload_url.outputs.upload_url }}
        asset_path: ${{ steps.filename.outputs.artifact_path }}
        asset_name: ${{ steps.filename.outputs.artifact_name }}
        asset_content_type: application/octet-stream

  publish_version:
    if: contains(github.ref, 'tags/v')

    name: Publish version.txt
    runs-on: ubuntu-latest
    needs: release

    steps:
    - name: Download version.txt
      uses: actions/download-artifact@v1
      with:
        name: version.txt
        path: ./

    - name: Download URL
      uses: actions/download-artifact@v1
      with:
        name: upload_url
        path: ./
    - id: set_upload_url
      run: |
        upload_url=`cat ./upload_url`
        echo ::set-output name=upload_url::$upload_url

    - name: Upload version.txt to Release
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.set_upload_url.outputs.upload_url }}
        asset_path: ./version.txt
        asset_name: version.txt
        asset_content_type: text/plain