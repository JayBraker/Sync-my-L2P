name: Build

on: [push]

env:
  QT_RELEASE: "qt6"
  QT_VERSION: "6.1.0"
  QT_CREATOR_VERSION: "6.0.2"
  CMAKE_VERSION: 3.19.8
  NINJA_VERSION: 1.10.1
  XCODE_VERSION: "12.1.1"
  INSTALL_BUILDER_VERSION: "20.4.0"
  PRODUCT_PRO: "Sync-my-L2P.pro"
  PRODUCT_NAME: "SyncMyL2P"
  CLIENT_ID: ${{ secrets.CLIENT_ID }}
  INSTALLBUILDER_LICENSE: ${{ secrets.INSTALLBUILDER_LICENSE }}
  VCINSTALLDIR: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC" # needed for installbuilder to locate vcredist

jobs:
  build:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      matrix:
        config:
        - {
            name: "Windows x64",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-windows-x64.exe",
            os: windows-2019,
            environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat"
          }
        - {
            name: "Linux",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-linux.AppImage",
            os: ubuntu-20.04
          }
        - {
            name: "macOS",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-osx.dmg",
            os: macos-10.15
          }

    steps:
    - uses: actions/checkout@v2

    - name: Parse product version
      id: version
      shell: cmake -P {0}
      run: |
        
        file(READ ./include/version.h version_h_content)
        string(REGEX MATCH "#define PRODUCT_VERSION_CODE ([0-9]+)" unused "${version_h_content}")
        set(version_code ${CMAKE_MATCH_1})
        string(REGEX MATCH "#define PRODUCT_VERSION \"([^\"]+)\"" unused "${version_h_content}")
        set(version_humanreadable ${CMAKE_MATCH_1})
        # store for upload
        file(WRITE ./version.txt "${version_code}")
        file(WRITE ./version_humanreadable.txt "${version_humanreadable}")
        # store for use in other steps
        message("::set-output name=code::${version_code}")
        message("::set-output name=humanreadable::${version_humanreadable}")

    - name: Upload human-readable version
      if: contains(github.ref, 'tags/v')
      uses: actions/upload-artifact@v1
      with:
        name: version_humanreadable.txt
        path: ./version_humanreadable.txt

    - name: Inserting OAuth 2.0 Client ID in Header file
      shell: cmake -P {0}
      run: |
        file(READ ./include/clientId.h clientid_h_content)
        string(REGEX REPLACE "#define CLIENTID[^\r\n]*" "#define CLIENTID \"$ENV{CLIENT_ID}\"" clientid_h_content "${clientid_h_content}")
        string(REGEX REPLACE "#error[^\r\n]*" "" clientid_h_content "${clientid_h_content}")
        file(WRITE ./include/clientId.h "${clientid_h_content}")

    - name: Download Ninja and CMake
      shell: cmake -P {0}
      run: |
        set(cmake_version "$ENV{CMAKE_VERSION}")
        set(ninja_version "$ENV{NINJA_VERSION}")

        if ("${{ runner.os }}" STREQUAL "Windows")
          set(ninja_suffix "win.zip")
          set(cmake_suffix "win64-x64.zip")
          set(cmake_dir "cmake-${cmake_version}-win64-x64/bin")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(ninja_suffix "linux.zip")
          set(cmake_suffix "Linux-x86_64.tar.gz")
          set(cmake_dir "cmake-${cmake_version}-Linux-x86_64/bin")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(ninja_suffix "mac.zip")
          set(cmake_suffix "Darwin-x86_64.tar.gz")
          set(cmake_dir "cmake-${cmake_version}-Darwin-x86_64/CMake.app/Contents/bin")
        endif()

        set(ninja_url "https://github.com/ninja-build/ninja/releases/download/v${ninja_version}/ninja-${ninja_suffix}")
        file(DOWNLOAD "${ninja_url}" ./ninja.zip SHOW_PROGRESS)
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./ninja.zip)

        set(cmake_url "https://github.com/Kitware/CMake/releases/download/v${cmake_version}/cmake-${cmake_version}-${cmake_suffix}")
        file(DOWNLOAD "${cmake_url}" ./cmake.zip SHOW_PROGRESS)
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./cmake.zip)

        # Add to PATH environment variable
        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/${cmake_dir}" cmake_dir)
        set(path_separator ":")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(path_separator ";")
        endif()
        file(APPEND "$ENV{GITHUB_PATH}" "$ENV{GITHUB_WORKSPACE}${path_separator}${cmake_dir}")

        if (NOT "${{ runner.os }}" STREQUAL "Windows")
          execute_process(
            COMMAND chmod +x ninja
            COMMAND chmod +x ${cmake_dir}/cmake
          )
        endif()

    - name: Installing system libs
      id: syslibs
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Linux")
          execute_process(
            COMMAND sudo apt install libgl1-mesa-dev libxkbcommon-x11-0
          )
        endif()

    - name: Download Qt
      id: qt
      shell: cmake -P {0}
      run: |
        set(qt_version $ENV{QT_VERSION})

        string(REPLACE "." "" qt_version_dotless "${qt_version}")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(url_os "windows_x86")
          set(qt_package_name "qt.$ENV{QT_RELEASE}.${qt_version_dotless}.win64_msvc2019_64")
          set(qt_dir_prefix "${qt_version}/msvc2019_64")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(url_os "linux_x64")
          set(qt_package_name "qt.$ENV{QT_RELEASE}.${qt_version_dotless}.gcc_64")
          set(qt_dir_prefix "${qt_version}/gcc_64")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(url_os "mac_x64")
          set(qt_package_name "qt.$ENV{QT_RELEASE}.${qt_version_dotless}.clang_64")
          set(qt_dir_prefix "${qt_version}/clang_64")
        endif()

        set(qt_base_url "https://download.qt.io/online/qtsdkrepository/${url_os}/desktop/$ENV{QT_RELEASE}_${qt_version_dotless}")
        file(DOWNLOAD "${qt_base_url}/Updates.xml" ./Updates.xml SHOW_PROGRESS)

        file(READ ./Updates.xml updates_xml)
        string(REGEX MATCH "<Name>${qt_package_name}.*<Version>([0-9+-.]+)</Version>.*<DownloadableArchives>qtbase([a-zA-Z0-9_-]+).7z"
          updates_xml_output "${updates_xml}")
        set(package_version ${CMAKE_MATCH_1})
        set(package_suffix ${CMAKE_MATCH_2})
        string(REPLACE "-debug-symbols" "" package_suffix "${package_suffix}")

        file(MAKE_DIRECTORY "$ENV{QT_RELEASE}")

        # Save the path for other steps
        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/$ENV{QT_RELEASE}/${qt_dir_prefix}" qt_dir)
        message("::set-output name=qt_dir::${qt_dir}")

        function(downloadAndExtract url archive)
          message("Downloading ${url}")
          file(DOWNLOAD "${url}" ./${archive} SHOW_PROGRESS)
          execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ../${archive} WORKING_DIRECTORY "$ENV{QT_RELEASE}" RESULT_VARIABLE result)
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()
        endfunction()

        message("Downloading Qt to ${qt_dir}")
        foreach(package qtbase qtdeclarative qttools qtsvg qttranslations)
          downloadAndExtract(
            "${qt_base_url}/${qt_package_name}/${package_version}${package}${package_suffix}.7z"
            ${package}.7z
          )
        endforeach()

        # uic depends on libicu56.so
        if ("${{ runner.os }}" STREQUAL "Linux")
          downloadAndExtract(
            "${qt_base_url}/${qt_package_name}/${package_version}icu-linux-Rhel7.2-x64.7z"
            icu.7z
          )
        endif()

        file(READ "$ENV{QT_RELEASE}/${qt_dir_prefix}/mkspecs/qconfig.pri" qtconfig)
        string(REPLACE "Enterprise" "OpenSource" qtconfig "${qtconfig}")
        string(REPLACE "licheck.exe" "" qtconfig "${qtconfig}")
        string(REPLACE "licheck64" "" qtconfig "${qtconfig}")
        string(REPLACE "licheck_mac" "" qtconfig "${qtconfig}")
        file(WRITE "$ENV{QT_RELEASE}/${qt_dir_prefix}/mkspecs/qconfig.pri" "${qtconfig}")

    - name: Download Qt Tool OpenSSL
      if: runner.os == 'Windows'
      shell: cmake -P {0}
      run: |
        set(qt_package_name "qt.tools.openssl.win_x64")
        set(qt_package_folder "tools_openssl_x64")
        set(qt_base_url "https://download.qt.io/online/qtsdkrepository/windows_x86/desktop/${qt_package_folder}")
        file(DOWNLOAD "${qt_base_url}/Updates.xml" ./Updates.xml SHOW_PROGRESS)

        file(READ ./Updates.xml updates_xml)
        string(REGEX MATCH "<Name>${qt_package_name}.*<Version>([0-9+-.]+)</Version>.*<DownloadableArchives>(openssl[a-zA-Z0-9._-]+).7z"
          updates_xml_output "${updates_xml}")
        set(package_version ${CMAKE_MATCH_1})
        set(package_name ${CMAKE_MATCH_2})
        string(REPLACE "-debug-symbols" "" package_name "${package_name}")

        file(DOWNLOAD
          "${qt_base_url}/${qt_package_name}/${package_version}${package_name}.7z" ./openssl.7z
          SHOW_PROGRESS
        )
        execute_process(
          COMMAND ${CMAKE_COMMAND} -E tar xvf ../openssl.7z
          WORKING_DIRECTORY "$ENV{QT_RELEASE}"
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

    - name: Download Qt Creator
      id: qt_creator
      shell: cmake -P {0}
      run: |
        string(REGEX MATCH "([0-9]+.[0-9]+).[0-9]+" outvar "$ENV{QT_CREATOR_VERSION}")

        set(qtc_base_url "https://download.qt.io/official_releases/qtcreator/${CMAKE_MATCH_1}/$ENV{QT_CREATOR_VERSION}/installer_source")

        if ("${{ runner.os }}" STREQUAL "Windows")
          set(qtc_output_directory "bin")
          set(qtc_platform "windows_x64")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(qtc_output_directory "bin")
          set(qtc_platform "linux_x64")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(qtc_output_directory "bin/Sync-my-L2P.app/Contents/MacOS")
          set(qtc_platform "mac_x64")
        endif()

        # Save the path for other steps
        message("::set-output name=qtc_output_directory::${qtc_output_directory}")

        file(MAKE_DIRECTORY qtcreator)

        message("Downloading Qt Creator from ${qtc_base_url}/${qtc_platform}")
        file(DOWNLOAD
          "${qtc_base_url}/${qtc_platform}/qtcreator.7z" ./qtcreator.7z SHOW_PROGRESS)
        execute_process(
          COMMAND ${CMAKE_COMMAND} -E tar xvf ../qtcreator.7z
          WORKING_DIRECTORY qtcreator
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

        if ("${{ runner.os }}" STREQUAL "macOS")
          execute_process(
            COMMAND ${CMAKE_COMMAND} -E make_directory qtcreator/bin
            COMMAND ${CMAKE_COMMAND} -E create_symlink
              "$ENV{GITHUB_WORKSPACE}/qtcreator/Qt Creator.app"
              "$ENV{GITHUB_WORKSPACE}/qtcreator/bin/Qt Creator.app"
          )
        endif()

        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/qtcreator" qtc_directory)

        # Save the path for other steps
        message("::set-output name=qtc_directory::${qtc_directory}")

        # Download jom
        if ("${{ runner.os }}" STREQUAL "Windows")
          file(DOWNLOAD "https://download.qt.io/official_releases/jom/jom_1_1_3.zip" ./jom.zip SHOW_PROGRESS)
          file(ARCHIVE_EXTRACT
            INPUT ./jom.zip
            DESTINATION qtcreator/bin
            VERBOSE
          )
        endif()

    - name: Download VMware InstallBuilder
      if: runner.os == 'Windows'
      id: installbuilder
      shell: cmake -P {0}
      run: |
        set(ib_installer "installbuilder-enterprise-$ENV{INSTALL_BUILDER_VERSION}-windows-installer.exe")
        set(ib_installer_url "https://installbuilder.com/${ib_installer}")

        file(MAKE_DIRECTORY installbuilder)

        file(DOWNLOAD
          "${ib_installer_url}" ./${ib_installer} SHOW_PROGRESS)
        execute_process(COMMAND
          ./${ib_installer} --mode unattended --prefix ./installbuilder)

        # insert license
        file(READ ./windows/license.xml.template license_xml_content)
        string(REGEX REPLACE "<signature>[^\r\n]*</signature>" "<signature>$ENV{INSTALLBUILDER_LICENSE}</signature>" license_xml_content "${license_xml_content}")
        file(WRITE ./installbuilder/license.xml "${license_xml_content}")

    - name: Configure
      shell: cmake -P {0}
      run: |
        if (NOT "${{ runner.os }}" STREQUAL "Windows")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/Qt/lib:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator/plugins:$ENV{LD_LIBRARY_PATH}")
        endif()

        if ("${{ runner.os }}" STREQUAL "Windows" AND NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
          execute_process(
            COMMAND "${{ matrix.config.environment_script }}" && set
            OUTPUT_FILE environment_script_output.txt
          )
          file(STRINGS environment_script_output.txt output_lines)
          foreach(line IN LISTS output_lines)
            if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
              set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
            endif()
          endforeach()
        endif()

        if ("${{ runner.os }}" STREQUAL "macOS")
          execute_process(
            COMMAND sudo xcode-select -s /Applications/Xcode_$ENV{XCODE_VERSION}.app/Contents/Developer
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()
        endif()

        execute_process(
          COMMAND cmake
            -DCMAKE_PREFIX_PATH=./"$ENV{QT_RELEASE}";./qtcreator
            -DCMAKE_BUILD_TYPE=Release
            -G Ninja
            -DCMAKE_C_COMPILER=${{ matrix.config.c_compiler }}
            -DCMAKE_CXX_COMPILER=${{ matrix.config.cxx_compiler }}
            -DCMAKE_MAKE_PROGRAM=ninja
            -DQT_DIR=${{ steps.qt.outputs.qt_dir }}
            .
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

    - name: Build
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Windows")
          if (NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
            execute_process(
              COMMAND "${{ matrix.config.environment_script }}" && set
              OUTPUT_FILE environment_script_output.txt
            )
            file(STRINGS environment_script_output.txt output_lines)
            foreach(line IN LISTS output_lines)
              if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
                set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
              endif()
            endforeach()
          endif()
          set(ENV{PATH} "${{ steps.qt.outputs.qt_dir }}/bin/;$ENV{PATH}")
        else()
          set(ENV{PATH} "${{ steps.qt.outputs.qt_dir }}/bin/:$ENV{PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/Qt/lib:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator:$ENV{LD_LIBRARY_PATH}")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt_creator.outputs.qtc_directory }}/lib/qtcreator/plugins:$ENV{LD_LIBRARY_PATH}")
          if ("${{ runner.os }}" STREQUAL "Linux")
            set(ENV{LD_LIBRARY_PATH} "$ENV{GITHUB_WORKSPACE}/linux/lib:$ENV{LD_LIBRARY_PATH}")
          endif()
        endif()

        execute_process(
          COMMAND cmake --build .
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

    - uses: apple-actions/import-codesign-certs@v1
      if: runner.os == 'macOS'
      with: 
        p12-file-base64: ${{ secrets.APPLE_CERTIFICATES_P12 }}
        p12-password: ${{ secrets.APPLE_CERTIFICATES_P12_PASSWORD }}

    - name: Create installer
      id: installer
      shell: cmake -P {0}
      run: |
        string(REPLACE "PRODUCT_VERSION" "${{ steps.version.outputs.humanreadable }}" artifact_name "${{ matrix.config.artifact }}")
        set(artifact_path "./${artifact_name}")

        # Save installer name and path for the next step
        message("::set-output name=artifact_name::${artifact_name}")
        message("::set-output name=artifact_path::${artifact_path}")

        if ("${{ runner.os }}" STREQUAL "Windows")
          execute_process(
            COMMAND ${{ steps.qt.outputs.qt_dir }}/bin/windeployqt
              "${{ steps.qt_creator.outputs.qtc_output_directory }}"
              --compiler-runtime
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          set(installer_platform "windows-x64")
          endif()

          execute_process(
            COMMAND ./installbuilder/bin/builder-cli.exe
              build
              ./windows/SyncMyL2P.xml
              ${installer_platform}
              --license ./installbuilder/license.xml
              --verbose
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          file(RENAME "./windows/build/$ENV{PRODUCT_NAME}-${{ steps.version.outputs.humanreadable }}-${installer_platform}-installer.exe" "${artifact_path}")

        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(ENV{LD_LIBRARY_PATH} "${{ steps.qt.outputs.qt_dir }}/lib/")
          set(ENV{VERSION} "${{ steps.version.outputs.humanreadable }}")

          # Get the latest release of linuxdeploy - Compatible with latest QT          
          file(DOWNLOAD "https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage" ./linux/linuxdeploy-x86_64.AppImage SHOW_PROGRESS)
          execute_process(COMMAND chmod +x linuxdeploy-x86_64.AppImage WORKING_DIRECTORY "$ENV{GITHUB_WORKSPACE}/linux/")

          # Make sure to convert DOS linebreaks to unix
          execute_process(COMMAND dos2unix Sync-my-L2P.desktop WORKING_DIRECTORY ./build/usr/share/applications/)
          
          # Produce AppImage
          execute_process(
            COMMAND linux/linuxdeploy-x86_64.AppImage 
                --appdir=AppDir # Directory to assemble the app
                --executable=bin/Sync-my-L2P # Path to compiled binary
                -d linux/Sync-my-L2P.desktop # Path to Desktop file
                -i linux/hicolor/16x16/apps/sync-my-L2P.png
                -i linux/hicolor/32x32/apps/sync-my-L2P.png
                -i linux/hicolor/48x48/apps/sync-my-L2P.png
                -i linux/hicolor/128x128/apps/sync-my-L2P.png
                --output appimage # Use AppImage plugin to create the AppImage instead of just file structure
            WORKING_DIRECTORY "$ENV{GITHUB_WORKSPACE}" RESULT_VARIABLE rv
          )         

          file(RENAME "./linux/Sync-my-L1P-$ENV{VERSION}-x86_64.AppImage" "${artifact_path}")

        elseif ("${{ runner.os }}" STREQUAL "macOS")
          execute_process(
            COMMAND npm install -g create-dmg fileicon
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL -1)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND brew install akeru-inc/tap/xcnotary
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND ${{ steps.qt.outputs.qt_dir }}/bin/macdeployqt Sync-my-L2P.app -sign-for-notarization=${{ secrets.APPLE_SIGNING_IDENTITY_NAME }}
            WORKING_DIRECTORY ./bin
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND fileicon set Sync-my-L2P.app ../magnifier.ico
            WORKING_DIRECTORY ./bin
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND xcrun altool --store-password-in-keychain-item DEVELOPER_SECRET -u "${{ secrets.APPLE_DEVELOPER_ACCOUNT }}" -p "${{ secrets.APPLE_DEVELOPER_SECRET }}"
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND xcnotary notarize Sync-my-L2P.app --developer-account "${{ secrets.APPLE_DEVELOPER_ACCOUNT }}" --developer-password-keychain-item DEVELOPER_SECRET
            WORKING_DIRECTORY ./bin
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(
            COMMAND create-dmg Sync-my-L2P.app
            WORKING_DIRECTORY ./bin
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          file(RENAME "./bin/Sync-my-L2P ${{ steps.version.outputs.humanreadable }}.dmg" "${artifact_path}")
        endif()

    - uses: actions/upload-artifact@v1
      id: upload_artifact
      with:
        name: ${{ steps.installer.outputs.artifact_name }}
        path: ${{ steps.installer.outputs.artifact_path }}

  release:
    if: contains(github.ref, 'tags/v')
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1.0.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

    - name: Store Release url
      run: |
        echo "${{ steps.create_release.outputs.upload_url }}" > ./upload_url

    - uses: actions/upload-artifact@v1
      with:
        path: ./upload_url
        name: upload_url

  publish:
    if: contains(github.ref, 'tags/v')

    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      matrix:
        config:
        - {
            name: "Windows x64",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-windows-x64.exe",
            os: ubuntu-latest
          }
        - {
            name: "Linux",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-linux.AppImage",
            os: ubuntu-latest
          }
        - {
            name: "macOS",
            artifact: "$ENV{PRODUCT_NAME}-PRODUCT_VERSION-osx.dmg",
            os: ubuntu-latest
          }
    needs: release

    steps:
    - name: Download human-readable version
      uses: actions/download-artifact@v1
      with:
        name: version_humanreadable.txt
        path: ./

    - name: Generate filename for upload
      id: filename
      shell: cmake -P {0}
      run: |
        file(READ ./version_humanreadable.txt version_humanreadable)
        string(REPLACE "PRODUCT_VERSION" "${version_humanreadable}" artifact_name "${{ matrix.config.artifact }}")

        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/${artifact_name}" artifact_path)
        
        # store for use in other steps
        message("::set-output name=artifact_name::${artifact_name}")
        message("::set-output name=artifact_path::${artifact_path}")

    - name: Download artifact
      uses: actions/download-artifact@v1
      with:
        name: ${{ steps.filename.outputs.artifact_name }}
        path: ./

    - name: Download URL
      uses: actions/download-artifact@v1
      with:
        name: upload_url
        path: ./
    - id: set_upload_url
      run: |
        upload_url=`cat ./upload_url`
        echo ::set-output name=upload_url::$upload_url

    - name: Upload to Release
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.set_upload_url.outputs.upload_url }}
        asset_path: ${{ steps.filename.outputs.artifact_path }}
        asset_name: ${{ steps.filename.outputs.artifact_name }}
        asset_content_type: application/octet-stream

  cleanup:
    if: contains(github.ref, 'tags/v')
    runs-on: ubuntu-latest
    needs: publish
    
    steps:
    - name: Delete human-readable version artifact
      uses: jimschubert/delete-artifacts-action@v1
      with:
        log_level: 'debug'
        artifact_name: 'version_humanreadable.txt'
